# Next time we revisit this, consider some changes. First, split this file into
# two. One part has the two functions we use: submission_server() and
# submission_ui. The second part has all the helper functions.

# Second, bringing in the learnr functions somehow. I hate being dependent on
# learnr given how unresponsive they are. We could just make copies of the
# functions we use. Or we could just incorporate the key code from those
# functions where we need them.

# Third, consider getting rid of all these helper functions. If we only use
# something once, I don't think we need a separate function. And, indeed, for
# some of this checking, maybe we don't need it at all. We could delete
# check_server_context() and is_server_context(). We only use a couple of lines
# from encode_obj().

# What we really want is a single function which, when called from the tutorial,
# does all the stuff we need. But, presumably, that is impossible. We need (?) a
# Shiny server and Shiny ui. This is not (?) any other way to produce this
# effect.

# Want to change the color to the OK box so that it is green when students enter
# their email or other text. This seem relevant:

# https://stackoverflow.com/questions/33620133/change-the-color-of-action-button-in-shiny/35871042

# But where, exactly, do we add this code given that we don't control the Shiny
# sessions which learnr itself starts and stops?

# Ought to understand and explain exactly what shiny::div() does.

# Add in a function (here?) for parsing the resulting RDS files.

# Add in a function (here?) for pulling out an answer key to share with
# students. Maybe we distribute a PDF in order to make copy/pasting harder?



#' @title Tutorial submission functions
#'
#' @description
#'
#' The following function was modified from Colin Rundel's learnrhash package,
#' available at https://github.com/rundel/learnrhash. Many thanks to Professor
#' Rundel, who has developed a fantastic tool for courses that teach R and use
#' the learnr package.
#'
#' This note is also modified from Professor Rundel's description: Note that
#' when including these functions in a learnr Rmd document it is necessary that
#' the server function, `submission_server()`, be included in an R chunk where
#' `context="server"`. Conversely, any of the ui functions, `*_ui()`, must *not*
#' be included in an R chunk with a `context`.
#'
#' @param input unused
#' @param output unused
#' @param session used to get current directory of tutorial
#'
#' @rdname submission_functions
#' @export

submission_server <- function(input, output, session) {
  p = parent.frame()
  check_server_context(p)

  # We need information from the parent frame --- from the learnr code which is
  # running this tutorial. This is the environment which is calling this
  # function, submission_server. Only this parent environment has access to
  # objects (like input, output, and session) which we need to access. So,
  # local() makes everything below evaluated in the parent frame.

  local({

    build_html <- function(file){



      # Inspired by Matt Blackwell's implementation of a similar idea.
      # https://github.com/mattblackwell/qsslearnr/blob/main/R/submission.R
      #
      # In order to keep same question order as in the exercise,
      # use parsermd to define factor level for exercise order
      # and store it in label_list
      #
      # information-name, information-email, download-answers-1
      # are questions that are part of the child documents, which
      # remain constant. Therefore, they are added in manually.

      manual_list <- list("information-name", "information-email", "download-answers-1")

      rmd_path <- file.path(session$options$appDir, "tutorial.Rmd")

      rmd <- parsermd::parse_rmd(rmd_path)

      rmd_tbl <- parsermd::as_tibble(rmd)

      rmd_chunk_labels <- dplyr::filter(rmd_tbl, rmd_tbl$type == "rmd_chunk")$label

      label_list <- c(manual_list, rmd_chunk_labels)

      # Create function to map objects over that will
      # return different results based on if it is a
      # code or question exercise.

      question_or_exercise <- function(obj, ...){
        options <- list(...)
        if (obj$type[[1]] == "exercise_submission"){
          obj$data$code[[1]]
        }else if (obj$type[[1]] == "question_submission"){
          obj$data$answer[[1]]
        }else{
          options$default
        }
      }

      # Copy over a report Rmd template to write to.

      tempReport <- file.path(tempdir(), "submission-temp.Rmd")
      file.copy("../../www/submission-temp.Rmd", tempReport, overwrite = TRUE)

      objs <- learnr:::get_all_state_objects(session)
      objs <- learnr:::submissions_from_state_objects(objs)


      # obj$data$answer[[1]] question answer
      # obj$data$code[[1]] "exercise answer"
      # obj$type[[1]] "exercise_submission"
      # obj$id[[1]] "id"

      # Format objs from learnr into a tibble
      # and reorder tibble rows based on label_list

      out <- tibble::tibble(
        id = purrr::map_chr(objs, "id",
                            .default = NA),
        submission_type = purrr::map_chr(objs, "type",
                                         .default = NA),
        answer = purrr::map(objs, question_or_exercise,
                            .default = NA)
      )

      out$id <- factor(out$id, levels = label_list)

      out <- dplyr::arrange(out, out$id)

      # Pass tibble and title as parameters into
      # the report template, then render template as
      # an html document.

      params <- list(
        output = out,
        title = paste0(learnr:::read_request(session, "tutorial.tutorial_id"), " submissions")
      )

      rmarkdown::render(tempReport,
                        output_format = "html_document",
                        output_file = file,
                        params = params,
                        envir = new.env(parent = globalenv())
                        )


  }

    output$downloadHtml <- shiny::downloadHandler(
      filename = paste0(learnr:::read_request(session, "tutorial.tutorial_id"),
                        "_answers.html"),
      content = build_html
    )

    output$downloadRds <- shiny::downloadHandler(

      # Next code chunk is key. downloadHandler is a function, one of the
      # arguments for which is filename. We want to have the file name be
      # different for each tutorial. But how do we know the name of the tutorial
      # in the middle of the session? It is easy to access some information from
      # the session object if we know the correct learnr function. (Note that
      # the call to session only seems to work within a reactive function like
      # this.)

      filename = paste0(learnr:::read_request(session, "tutorial.tutorial_id"),
                        "_answers.rds"),

      content = function(file){

        # We used to execute the next two lines in a separate step, requiring
        # users to generate the hash by pressing a button. But this is hardly
        # necessary. We can just do it here, whenever users press the download
        # button. Would be nice to get the learnr people to export these
        # functions so that the ::: hack is not necessary. I have submitted a
        # request: https://github.com/rstudio/learnr/issues/454. The functions
        # are small, so we might just copy them over. But given that we need
        # learnr regardless, that seems excessive.

        objs <- learnr:::get_all_state_objects(session)
        objs <- learnr:::submissions_from_state_objects(objs)

        responses <- encode_obj(objs)
        readr::write_rds(responses, file)
      }
    )

  }, envir = p)
}

check_server_context <- function(.envir) {
  if (!is_server_context(.envir)) {
    calling_func = deparse(sys.calls()[[sys.nframe()-1]])

    err = paste0(
      "Function `", calling_func,"`",
      " must be called from an Rmd chunk where `context = \"server\"`"
    )

    stop(err, call. = FALSE)
  }
}

is_server_context <- function(.envir) {
  # We are in the server context if there are the follow:
  # * input - input reactive values
  # * output - shiny output
  # * session - shiny session
  #
  # Check context by examining the class of each of these.
  # If any is missing then it will be a NULL which will fail.

  inherits(.envir$input,   "reactivevalues") &
    inherits(.envir$output,  "shinyoutput")    &
    inherits(.envir$session, "ShinySession")
}

#' Encode an R object into hashed text; from github::rundel/learnrhash
#'
#' @param obj R object
#' @param compress Compression method.
#'
#' @export

# DK: We can delete this next function and just hard code
# the encoding call above.

encode_obj = function(obj, compress = c("bzip2", "gzip", "xz", "none"))  {
  compress = match.arg(compress)

  raw = serialize(obj, NULL)
  comp_raw = memCompress(raw, type = compress)

  base64enc::base64encode(comp_raw)
}


#' @rdname submission_functions
#' @export

submission_ui <- shiny::div(

  "When you have completed this tutorial, follow these steps:",

  shiny::tags$br(),
  shiny::tags$ol(
    shiny::tags$li("Click the Download button below to download a file containing your answer. A window will pop up."),
    shiny::tags$li("Save the file onto your computer in a convenient location. It should have an 'rds' suffix. Do not open it."),
    shiny::tags$li("Submit the file which you just downloaded as instructed.")),
  shiny::fluidPage(
    shiny::mainPanel(
      shiny::div(id = "form",
                 shiny::downloadButton(outputId = "downloadRds", label = "Download RDS"),
                 shiny::downloadButton(outputId = "downloadHtml", label = "Download HTML"))
    )
  )
)


# Never understand what this hack does or why it is necessary.

utils::globalVariables(c("session", "page_num"))
